\vspace*{-0.4cm}
\section{Techniques description}

The different coding schemes that have been implemented rely on several transforms and entropy coders that are introduced here.

\subsection{Run-Length Encoding (RLE)}

The RLE transforms a bilevel image into a sequence of runs. A run is the number of successive occurrences of the same value in the file. For example, the sequence $[0,0,0,1,1,1,1]$ would be coded $[3,4]$ by a coder assuming the first received symbol is a $0$.

\subsection{Move to Front transform (MTF)}

The purpose of the MTF is to reduce the entropy of the image \cite{benzid}. It is also based on the concept of runs but replaces each symbol of a run by 0 except the first one. The first one is replaced by the index of the symbol in the alphabet of the source. For example, for a sequence $[1,1,1,0,0,0,0]$, the alphabet is $[0,1]$. The index of 1 in the alphabet is 1, so that the sequence becomes $[\textbf{1},\textbf{0},\textbf{0},0,0,0,0]$. The 1 is moved to the front of the alphabet (hence the name of the MTF), and the sequence of 0's now needs to be encoded. The alphabet is now $[1,0]$, so that the index of 0 is 1. The final sequence is $[1,0,0,1,0,0,0]$ and the final alphabet is $[0,1]$.

\subsection{Two-Role Encoder (TRE)}

The TRE is a variant of the RLE which is more suited when one symbol is more probable than the other \cite{benzid}, so that it is meant to be used after the MTF. Each non-zero element is shifted by 8 bits, while the sequence of zeros is simply encoded as the run length. To follow the previous example, the sequence $[1,0,0,1,0,0,0]$ would be encoded as $[256,2,256,3]$. Here, the assumption that no run length will exceed 256 is done. The stream can be decoded knowing that a symbol that is repeated is encoded with a number greater than 255, while a run cannot be greater than 255.

\subsection{Exp-Golomb coding}

The Exp-Golomb coding is a variable length prefix code meant for entropy coding. The $i$\textsuperscript{th} symbol is mapped to the binary representation of $i+1$, preceded by M zeros with $M=\left \lfloor{\log_2(i)}\right \rfloor $. When the short codewords are assigned to most probable symbols, compression can be achieved \cite{H264}.

\subsection{Arithmetic coding}

An arithmetic encoder converts a sequence of data symbols into a single fractional number and can approach the optimal fractional number of bits required to represent each symbol. In general, it outperforms prefix codes \cite{H264}. An integer version of the coder was implemented to cope with finite precision problems. When the interval corresponding to the symbol stream becomes too small, some bits are already extracted and the interval is made wider again.