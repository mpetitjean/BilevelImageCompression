#include <iostream>
#include <set>
#include <cmath>
#include <algorithm>
#include <map>
#include "arithmetic.hpp"

std::map <uint32_t, uint32_t> probabilityInt(std::vector<uint32_t> encoded)
{
	/**
    Counts the probability of each value in 'encoded'

    @param 	vector to be processed
    @return a map of which the key is a value of 'encoded' and the corresponding value is its probabilty
    */
	
	std::map <uint32_t, uint32_t> occ;
	std::for_each(encoded.begin(), encoded.end(), [&occ](uint32_t val)
		{++occ[val];});
	return occ;
}

std::map<uint32_t, std::pair<uint32_t, uint32_t>> createIntervalsInt(std::map <uint32_t, uint32_t> occ, uint32_t &size)
{	
	/**
	Create a map to register the intervals for each symbol in order to implement the arithmetic encoder and decoder

    @param 	the map of occurences as generated by the function 'nbOccurences'
    @return a map containing 1) a symbol and 2) a pair of its corresponding interval
	*/

	// One symbol ‚ü∑ one pair [min, max)
	std::map<uint32_t, std::pair<uint32_t, uint32_t>> result;
	uint32_t high = 0;
	uint32_t low = 0;

	for (auto p : occ)
	{
		high += p.second;
		result[p.first] = std::pair<uint32_t, uint32_t>(low, high);
		low = high;
	}
	size = high;

	return result;
}	

std::string arithmeticEncoderInt(std::map<uint32_t, std::pair<uint32_t, uint32_t>> intervalsMap, std::vector<uint32_t> TREd, uint32_t size)
{
	/**
	Implementation of an arithmetic encoder using arbitrary precise numbers.
	The output is assigned by reference because it is not possible to output a type mpf_t

    @param	intervalsMap: map generated by 'createIntervals'
    		TREd: image to be encoded
    		outbuff: reference to an arbitrary precise number, output of the encoder
	*/
	std::string outbuff;
	uint32_t high = 0xFFFFFFFFU, low = 0, pending_bit = 0;
	uint64_t range;
	for (auto value : TREd)
	{
		range = (uint64_t)(high - low) + 1;
		//std::cout << range << std::endl;
	
		high = low + (range*intervalsMap[value].second) / size - 1;
		low = low + (range*intervalsMap[value].first) / size;

		while (1)
		{	
			if (high < 0x80000000U)
			{
				outbuff += "0";
				while (pending_bit--)
					outbuff += "1";
				pending_bit = 0;
				
			}
			else if (low >= 0x80000000U)
			{
				outbuff += "1";
				while (pending_bit--)
					outbuff += "0";
				pending_bit = 0;
				low -=  0x80000000U;
				high -= 0x80000000U;
			}
			else if ( low >= 0x40000000U && high < 0xC0000000U )
			{
				++pending_bit;
				low -= 0x40000000U;
				high -= 0x40000000U;
			} 
			else
				break;
			low <<= 1;
			high <<= 1;
			++high;
		}
	}
	++pending_bit;
	if ( low < 0x40000000U)
	{
    	outbuff += "0";
			while (pending_bit--)
				outbuff += "1";
	}
	else
	{
    	outbuff += "1";
			while (pending_bit--)
				outbuff += "0";
	}
	return outbuff;
}

std::vector<uint32_t> arithmeticDecoderInt(std::string encoded, std::map<uint32_t, std::pair<uint32_t, uint32_t>> intervalsMap, uint32_t size)
{
	/**
	Implementation of an arithmetic decoder using arbitrary precise numbers.
	Number 0 is defined as EOF.

    @param	encoded: arbitrary precise number, output of the encoder
    		intervalsMap: map generated by 'createIntervals'
	@return the decoded vector
	*/
	// std::vector<uint32_t> decoded(2);
	std::map<uint32_t, uint32_t> inverseIntervalsMap;
	for (auto val: intervalsMap)
		inverseIntervalsMap[val.second.first] = val.first;
	uint32_t high = 0xFFFFFFFFU, low = 0, value;
	uint64_t range, temp;
	std::vector<uint32_t> decoded;
	// printf("there\n");
	value = std::stoul(encoded.substr(0, 32), nullptr, 2);
	// std::cout << value << std::endl;
	encoded.erase(0, 32);

	do
	{
		range = (uint64_t)(high - low) + 1;
		temp = ((uint64_t)(value - low + 1) * size - 1) / range;
		// std::cout << temp << std::endl;
		decoded.push_back((*(--inverseIntervalsMap.upper_bound(temp))).second);
		high = low + (range*intervalsMap[decoded.back()].second) / size - 1;
		low = low + (range*intervalsMap[decoded.back()].first) / size;
		while (1)
		{
			if (high < 0x80000000U)
			{}
			else if (low >= 0x80000000U)
			{
				low -=  0x80000000U;
				high -= 0x80000000U;
				value -= 0x80000000U;
			}
			else if ( low >= 0x40000000U && high < 0xC0000000U )
			{
				value -= 0x40000000U;
				low -= 0x40000000U;
				high -= 0x40000000U;
			} 
			else
				break;
			low <<= 1;
			high <<= 1;
			++high;
			value <<= 1;
			// printf("lol\n");
			value += encoded.empty() ? 1 : std::stoul(encoded.substr(0, 1), nullptr, 2);
			encoded.erase(0, 1);
		}
		// std::cout << decoded.back() << std::endl;
	}
	while(decoded.back() != (uint32_t) -1);

	return decoded;
}